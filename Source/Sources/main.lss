
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000370  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000030  00800060  00000370  00000404  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .eeprom       00000001  00810000  00810000  00000434  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .debug_aranges 00000080  00000000  00000000  00000435  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000000ff  00000000  00000000  000004b5  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000006ac  00000000  00000000  000005b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000031c  00000000  00000000  00000c60  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000005a3  00000000  00000000  00000f7c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000000c0  00000000  00000000  00001520  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000016a  00000000  00000000  000015e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000016f  00000000  00000000  0000174a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000c0  00000000  00000000  000018b9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	35 c0       	rjmp	.+106    	; 0x6c <__ctors_end>
   2:	45 c0       	rjmp	.+138    	; 0x8e <__bad_interrupt>
   4:	44 c0       	rjmp	.+136    	; 0x8e <__bad_interrupt>
   6:	43 c0       	rjmp	.+134    	; 0x8e <__bad_interrupt>
   8:	42 c0       	rjmp	.+132    	; 0x8e <__bad_interrupt>
   a:	41 c0       	rjmp	.+130    	; 0x8e <__bad_interrupt>
   c:	40 c0       	rjmp	.+128    	; 0x8e <__bad_interrupt>
   e:	3f c0       	rjmp	.+126    	; 0x8e <__bad_interrupt>
  10:	3e c0       	rjmp	.+124    	; 0x8e <__bad_interrupt>
  12:	3d c0       	rjmp	.+122    	; 0x8e <__bad_interrupt>

00000014 <frequences>:
  14:	93 02 4b 02 93 02 b8 01 00 00 ba 02 93 02 ba 02     ..K.............
  24:	93 02 4b 02 00 00 ba 02 93 02 ba 02 b8 01 00 00     ..K.............
  34:	4b 02 0b 02 4b 02 0b 02 dc 03 4b 02                 K...K.....K.

00000040 <durations>:
  40:	64 00 64 00 90 01 90 01 58 02 64 00 64 00 c8 00     d.d.....X.d.d...
  50:	c8 00 90 01 58 02 64 00 64 00 90 01 90 01 58 02     ....X.d.d.....X.
  60:	64 00 64 00 c8 00 c8 00 c8 00 c8 00                 d.d.........

0000006c <__ctors_end>:
  6c:	11 24       	eor	r1, r1
  6e:	1f be       	out	0x3f, r1	; 63
  70:	cf e9       	ldi	r28, 0x9F	; 159
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	10 e0       	ldi	r17, 0x00	; 0
  76:	a0 e6       	ldi	r26, 0x60	; 96
  78:	b0 e0       	ldi	r27, 0x00	; 0
  7a:	e0 e7       	ldi	r30, 0x70	; 112
  7c:	f3 e0       	ldi	r31, 0x03	; 3
  7e:	02 c0       	rjmp	.+4      	; 0x84 <.do_copy_data_start>

00000080 <.do_copy_data_loop>:
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0

00000084 <.do_copy_data_start>:
  84:	a0 39       	cpi	r26, 0x90	; 144
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <.do_copy_data_loop>
  8a:	02 d0       	rcall	.+4      	; 0x90 <main>
  8c:	6f c1       	rjmp	.+734    	; 0x36c <_exit>

0000008e <__bad_interrupt>:
  8e:	b8 cf       	rjmp	.-144    	; 0x0 <__vectors>

00000090 <main>:

#define REPEATER 5

int main (void)

{
  90:	1f 93       	push	r17
	
	uint8_t scenary =0x00;
	scenary = scenary_changer();
  92:	cf d0       	rcall	.+414    	; 0x232 <scenary_changer>
  94:	18 2f       	mov	r17, r24
	
	uint8_t i= 0;
	while(i<REPEATER)
	{
	animation(scenary);
  96:	2e d0       	rcall	.+92     	; 0xf4 <animation>
  98:	81 2f       	mov	r24, r17
  9a:	2c d0       	rcall	.+88     	; 0xf4 <animation>
  9c:	81 2f       	mov	r24, r17
  9e:	2a d0       	rcall	.+84     	; 0xf4 <animation>
  a0:	81 2f       	mov	r24, r17
  a2:	28 d0       	rcall	.+80     	; 0xf4 <animation>
  a4:	81 2f       	mov	r24, r17
  a6:	26 d0       	rcall	.+76     	; 0xf4 <animation>
	i++;
	
	}
	set_sleep_mode(SLEEP_MODE_PWR_DOWN);
  a8:	85 b7       	in	r24, 0x35	; 53
  aa:	87 7e       	andi	r24, 0xE7	; 231
  ac:	80 61       	ori	r24, 0x10	; 16
  ae:	85 bf       	out	0x35, r24	; 53
	sleep_enable(); 
  b0:	85 b7       	in	r24, 0x35	; 53
  b2:	80 62       	ori	r24, 0x20	; 32
  b4:	85 bf       	out	0x35, r24	; 53
    sleep_cpu();
  b6:	88 95       	sleep

}
  b8:	80 e0       	ldi	r24, 0x00	; 0
  ba:	90 e0       	ldi	r25, 0x00	; 0
  bc:	1f 91       	pop	r17
  be:	08 95       	ret

000000c0 <led_controlOn>:
}

void led_controlOn(uint8_t ledInit, uint8_t ledNumber)

{	
		DDRB |= ledInit;
  c0:	97 b3       	in	r25, 0x17	; 23
  c2:	98 2b       	or	r25, r24
  c4:	97 bb       	out	0x17, r25	; 23
		PORTB |= ledNumber;
  c6:	88 b3       	in	r24, 0x18	; 24
  c8:	86 2b       	or	r24, r22
  ca:	88 bb       	out	0x18, r24	; 24
	
}
  cc:	08 95       	ret

000000ce <led_controlOff>:

void led_controlOff(uint8_t ledInit, uint8_t ledNumber)

{	
		DDRB &= ~ledInit;
  ce:	97 b3       	in	r25, 0x17	; 23
  d0:	80 95       	com	r24
  d2:	98 23       	and	r25, r24
  d4:	97 bb       	out	0x17, r25	; 23
		PORTB &= ~ledNumber;;
  d6:	88 b3       	in	r24, 0x18	; 24
  d8:	60 95       	com	r22
  da:	86 23       	and	r24, r22
  dc:	88 bb       	out	0x18, r24	; 24
	
}
  de:	08 95       	ret

000000e0 <delay_ms>:
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  e0:	24 ec       	ldi	r18, 0xC4	; 196
  e2:	39 e0       	ldi	r19, 0x09	; 9
  e4:	04 c0       	rjmp	.+8      	; 0xee <delay_ms+0xe>
void delay_ms(uint8_t delay)

{
	while(delay)
	{	
		delay--;
  e6:	81 50       	subi	r24, 0x01	; 1
  e8:	f9 01       	movw	r30, r18
  ea:	31 97       	sbiw	r30, 0x01	; 1
  ec:	f1 f7       	brne	.-4      	; 0xea <delay_ms+0xa>
	
}
void delay_ms(uint8_t delay)

{
	while(delay)
  ee:	88 23       	and	r24, r24
  f0:	d1 f7       	brne	.-12     	; 0xe6 <delay_ms+0x6>
	{	
		delay--;
		_delay_loop_2(2500);
	}
}
  f2:	08 95       	ret

000000f4 <animation>:
0x02
};

void animation(uint8_t scenary)

{
  f4:	0f 93       	push	r16
  f6:	1f 93       	push	r17
  f8:	cf 93       	push	r28
  fa:	df 93       	push	r29
	uint8_t i=0;
	if(scenary ==0x00)
  fc:	88 23       	and	r24, r24
  fe:	39 f5       	brne	.+78     	; 0x14e <animation+0x5a>
 100:	40 e0       	ldi	r20, 0x00	; 0
 102:	50 e0       	ldi	r21, 0x00	; 0
 104:	64 ec       	ldi	r22, 0xC4	; 196
 106:	79 e0       	ldi	r23, 0x09	; 9
	{
	
	
	while(i<COUNTLED)
	{
		led_controlOn(ledInit[i], ledCtrl[i]);
 108:	fa 01       	movw	r30, r20
 10a:	e0 5a       	subi	r30, 0xA0	; 160
 10c:	ff 4f       	sbci	r31, 0xFF	; 255
 10e:	30 81       	ld	r19, Z
 110:	fa 01       	movw	r30, r20
 112:	e8 58       	subi	r30, 0x88	; 136
 114:	ff 4f       	sbci	r31, 0xFF	; 255
 116:	e0 81       	ld	r30, Z
}

void led_controlOn(uint8_t ledInit, uint8_t ledNumber)

{	
		DDRB |= ledInit;
 118:	87 b3       	in	r24, 0x17	; 23
 11a:	83 2b       	or	r24, r19
 11c:	87 bb       	out	0x17, r24	; 23
		PORTB |= ledNumber;
 11e:	88 b3       	in	r24, 0x18	; 24
 120:	8e 2b       	or	r24, r30
 122:	88 bb       	out	0x18, r24	; 24
 124:	29 e1       	ldi	r18, 0x19	; 25
void delay_ms(uint8_t delay)

{
	while(delay)
	{	
		delay--;
 126:	21 50       	subi	r18, 0x01	; 1
 128:	cb 01       	movw	r24, r22
 12a:	01 97       	sbiw	r24, 0x01	; 1
 12c:	f1 f7       	brne	.-4      	; 0x12a <animation+0x36>
	
}
void delay_ms(uint8_t delay)

{
	while(delay)
 12e:	22 23       	and	r18, r18
 130:	d1 f7       	brne	.-12     	; 0x126 <animation+0x32>
}

void led_controlOff(uint8_t ledInit, uint8_t ledNumber)

{	
		DDRB &= ~ledInit;
 132:	87 b3       	in	r24, 0x17	; 23
 134:	30 95       	com	r19
 136:	38 23       	and	r19, r24
 138:	37 bb       	out	0x17, r19	; 23
		PORTB &= ~ledNumber;;
 13a:	88 b3       	in	r24, 0x18	; 24
 13c:	e0 95       	com	r30
 13e:	e8 23       	and	r30, r24
 140:	e8 bb       	out	0x18, r30	; 24
 142:	4e 5f       	subi	r20, 0xFE	; 254
 144:	5f 4f       	sbci	r21, 0xFF	; 255
	uint8_t i=0;
	if(scenary ==0x00)
	{
	
	
	while(i<COUNTLED)
 146:	48 31       	cpi	r20, 0x18	; 24
 148:	51 05       	cpc	r21, r1
 14a:	f1 f6       	brne	.-68     	; 0x108 <animation+0x14>
 14c:	6d c0       	rjmp	.+218    	; 0x228 <animation+0x134>
		i++;
	}
	
	}
	
	if(scenary ==0x01)
 14e:	81 30       	cpi	r24, 0x01	; 1
 150:	a9 f5       	brne	.+106    	; 0x1bc <animation+0xc8>
 152:	e8 e7       	ldi	r30, 0x78	; 120
 154:	f0 e0       	ldi	r31, 0x00	; 0
 156:	a0 e9       	ldi	r26, 0x90	; 144
 158:	b0 e0       	ldi	r27, 0x00	; 0
 15a:	64 ec       	ldi	r22, 0xC4	; 196
 15c:	79 e0       	ldi	r23, 0x09	; 9
	{
	i=COUNTLED;
	while(i)
	{
		led_controlOn(ledInit[i], ledCtrl[i]);
 15e:	30 81       	ld	r19, Z
 160:	4c 91       	ld	r20, X
}

void led_controlOn(uint8_t ledInit, uint8_t ledNumber)

{	
		DDRB |= ledInit;
 162:	87 b3       	in	r24, 0x17	; 23
 164:	83 2b       	or	r24, r19
 166:	87 bb       	out	0x17, r24	; 23
		PORTB |= ledNumber;
 168:	88 b3       	in	r24, 0x18	; 24
 16a:	84 2b       	or	r24, r20
 16c:	88 bb       	out	0x18, r24	; 24
 16e:	29 e1       	ldi	r18, 0x19	; 25
void delay_ms(uint8_t delay)

{
	while(delay)
	{	
		delay--;
 170:	21 50       	subi	r18, 0x01	; 1
 172:	cb 01       	movw	r24, r22
 174:	01 97       	sbiw	r24, 0x01	; 1
 176:	f1 f7       	brne	.-4      	; 0x174 <animation+0x80>
	
}
void delay_ms(uint8_t delay)

{
	while(delay)
 178:	22 23       	and	r18, r18
 17a:	d1 f7       	brne	.-12     	; 0x170 <animation+0x7c>
}

void led_controlOff(uint8_t ledInit, uint8_t ledNumber)

{	
		DDRB &= ~ledInit;
 17c:	87 b3       	in	r24, 0x17	; 23
 17e:	30 95       	com	r19
 180:	38 23       	and	r19, r24
 182:	37 bb       	out	0x17, r19	; 23
		PORTB &= ~ledNumber;;
 184:	88 b3       	in	r24, 0x18	; 24
 186:	40 95       	com	r20
 188:	48 23       	and	r20, r24
 18a:	48 bb       	out	0x18, r20	; 24
 18c:	32 97       	sbiw	r30, 0x02	; 2
 18e:	12 97       	sbiw	r26, 0x02	; 2
	}
	
	if(scenary ==0x01)
	{
	i=COUNTLED;
	while(i)
 190:	80 e0       	ldi	r24, 0x00	; 0
 192:	e0 36       	cpi	r30, 0x60	; 96
 194:	f8 07       	cpc	r31, r24
 196:	19 f7       	brne	.-58     	; 0x15e <animation+0x6a>
}

void led_controlOn(uint8_t ledInit, uint8_t ledNumber)

{	
		DDRB |= ledInit;
 198:	87 b3       	in	r24, 0x17	; 23
 19a:	8a 60       	ori	r24, 0x0A	; 10
 19c:	87 bb       	out	0x17, r24	; 23
		PORTB |= ledNumber;
 19e:	c3 9a       	sbi	0x18, 3	; 24
 1a0:	29 e1       	ldi	r18, 0x19	; 25
 1a2:	44 ec       	ldi	r20, 0xC4	; 196
 1a4:	59 e0       	ldi	r21, 0x09	; 9
void delay_ms(uint8_t delay)

{
	while(delay)
	{	
		delay--;
 1a6:	21 50       	subi	r18, 0x01	; 1
 1a8:	ca 01       	movw	r24, r20
 1aa:	01 97       	sbiw	r24, 0x01	; 1
 1ac:	f1 f7       	brne	.-4      	; 0x1aa <animation+0xb6>
	
}
void delay_ms(uint8_t delay)

{
	while(delay)
 1ae:	22 23       	and	r18, r18
 1b0:	d1 f7       	brne	.-12     	; 0x1a6 <animation+0xb2>
}

void led_controlOff(uint8_t ledInit, uint8_t ledNumber)

{	
		DDRB &= ~ledInit;
 1b2:	87 b3       	in	r24, 0x17	; 23
 1b4:	85 7f       	andi	r24, 0xF5	; 245
 1b6:	87 bb       	out	0x17, r24	; 23
		PORTB &= ~ledNumber;;
 1b8:	c3 98       	cbi	0x18, 3	; 24
 1ba:	36 c0       	rjmp	.+108    	; 0x228 <animation+0x134>
		delay_ms(25);
		led_controlOff(ledInit[i], ledCtrl[i]);
	}
	
	}
	if(scenary ==0x02)
 1bc:	82 30       	cpi	r24, 0x02	; 2
 1be:	11 f4       	brne	.+4      	; 0x1c4 <animation+0xd0>
	{
		march();
 1c0:	52 d0       	rcall	.+164    	; 0x266 <march>
 1c2:	32 c0       	rjmp	.+100    	; 0x228 <animation+0x134>
	}

	if(scenary ==0x03)
 1c4:	83 30       	cpi	r24, 0x03	; 3
 1c6:	81 f5       	brne	.+96     	; 0x228 <animation+0x134>
 1c8:	c8 e7       	ldi	r28, 0x78	; 120
 1ca:	d0 e0       	ldi	r29, 0x00	; 0
 1cc:	a0 e9       	ldi	r26, 0x90	; 144
 1ce:	b0 e0       	ldi	r27, 0x00	; 0
 1d0:	60 e0       	ldi	r22, 0x00	; 0
 1d2:	70 e0       	ldi	r23, 0x00	; 0
 1d4:	04 ec       	ldi	r16, 0xC4	; 196
 1d6:	19 e0       	ldi	r17, 0x09	; 9
	{
	
	i=0;
	while(i<COUNTLED)
	{
		led_controlOn(ledInit[i]|ledInit[COUNTLED-i],ledCtrl[i]|ledCtrl[COUNTLED-i]);
 1d8:	fb 01       	movw	r30, r22
 1da:	e0 5a       	subi	r30, 0xA0	; 160
 1dc:	ff 4f       	sbci	r31, 0xFF	; 255
 1de:	48 81       	ld	r20, Y
 1e0:	80 81       	ld	r24, Z
 1e2:	48 2b       	or	r20, r24
 1e4:	fb 01       	movw	r30, r22
 1e6:	e8 58       	subi	r30, 0x88	; 136
 1e8:	ff 4f       	sbci	r31, 0xFF	; 255
 1ea:	3c 91       	ld	r19, X
 1ec:	80 81       	ld	r24, Z
 1ee:	38 2b       	or	r19, r24
}

void led_controlOn(uint8_t ledInit, uint8_t ledNumber)

{	
		DDRB |= ledInit;
 1f0:	87 b3       	in	r24, 0x17	; 23
 1f2:	84 2b       	or	r24, r20
 1f4:	87 bb       	out	0x17, r24	; 23
		PORTB |= ledNumber;
 1f6:	88 b3       	in	r24, 0x18	; 24
 1f8:	83 2b       	or	r24, r19
 1fa:	88 bb       	out	0x18, r24	; 24
 1fc:	24 e6       	ldi	r18, 0x64	; 100
void delay_ms(uint8_t delay)

{
	while(delay)
	{	
		delay--;
 1fe:	21 50       	subi	r18, 0x01	; 1
 200:	c8 01       	movw	r24, r16
 202:	01 97       	sbiw	r24, 0x01	; 1
 204:	f1 f7       	brne	.-4      	; 0x202 <animation+0x10e>
	
}
void delay_ms(uint8_t delay)

{
	while(delay)
 206:	22 23       	and	r18, r18
 208:	d1 f7       	brne	.-12     	; 0x1fe <animation+0x10a>
}

void led_controlOff(uint8_t ledInit, uint8_t ledNumber)

{	
		DDRB &= ~ledInit;
 20a:	87 b3       	in	r24, 0x17	; 23
 20c:	40 95       	com	r20
 20e:	48 23       	and	r20, r24
 210:	47 bb       	out	0x17, r20	; 23
		PORTB &= ~ledNumber;;
 212:	88 b3       	in	r24, 0x18	; 24
 214:	30 95       	com	r19
 216:	38 23       	and	r19, r24
 218:	38 bb       	out	0x18, r19	; 24
 21a:	6e 5f       	subi	r22, 0xFE	; 254
 21c:	7f 4f       	sbci	r23, 0xFF	; 255
 21e:	22 97       	sbiw	r28, 0x02	; 2
 220:	12 97       	sbiw	r26, 0x02	; 2

	if(scenary ==0x03)
	{
	
	i=0;
	while(i<COUNTLED)
 222:	68 31       	cpi	r22, 0x18	; 24
 224:	71 05       	cpc	r23, r1
 226:	c1 f6       	brne	.-80     	; 0x1d8 <animation+0xe4>
	}

	}
*/
	
}
 228:	df 91       	pop	r29
 22a:	cf 91       	pop	r28
 22c:	1f 91       	pop	r17
 22e:	0f 91       	pop	r16
 230:	08 95       	ret

00000232 <scenary_changer>:
#define MAX 0x03

uint8_t EEMEM startScenary;

uint16_t scenary_changer()
{
 232:	1f 93       	push	r17
	
	uint8_t ucData = 0x00;

	ucData = eeprom_read_byte (&startScenary);
 234:	80 e0       	ldi	r24, 0x00	; 0
 236:	90 e0       	ldi	r25, 0x00	; 0
 238:	83 d0       	rcall	.+262    	; 0x340 <__eerd_byte_tn13a>
 23a:	18 2f       	mov	r17, r24

	eeprom_write_byte (&startScenary, ucData+1);
 23c:	68 2f       	mov	r22, r24
 23e:	6f 5f       	subi	r22, 0xFF	; 255
 240:	80 e0       	ldi	r24, 0x00	; 0
 242:	90 e0       	ldi	r25, 0x00	; 0
 244:	85 d0       	rcall	.+266    	; 0x350 <__eewr_byte_tn13a>
	if((ucData>=MAX)|(ucData==0xFF))
 246:	13 30       	cpi	r17, 0x03	; 3
 248:	20 f0       	brcs	.+8      	; 0x252 <scenary_changer+0x20>
	{	
	eeprom_write_byte (&startScenary, 0x00);
 24a:	80 e0       	ldi	r24, 0x00	; 0
 24c:	90 e0       	ldi	r25, 0x00	; 0
 24e:	60 e0       	ldi	r22, 0x00	; 0
 250:	7f d0       	rcall	.+254    	; 0x350 <__eewr_byte_tn13a>
	}

	return ucData;
}
 252:	81 2f       	mov	r24, r17
 254:	90 e0       	ldi	r25, 0x00	; 0
 256:	1f 91       	pop	r17
 258:	08 95       	ret

0000025a <setup>:
#endif

 void setup() 	 
{ 	 
 
  	DDRB |= 0xFF;
 25a:	87 b3       	in	r24, 0x17	; 23
 25c:	8f ef       	ldi	r24, 0xFF	; 255
 25e:	87 bb       	out	0x17, r24	; 23
	PORTB |= 0x00;
 260:	88 b3       	in	r24, 0x18	; 24
 262:	88 bb       	out	0x18, r24	; 24
  
} 	 
 264:	08 95       	ret

00000266 <march>:
 
 


void march()
{ 	 
 266:	0f 93       	push	r16
 268:	1f 93       	push	r17
 26a:	cf 93       	push	r28
 26c:	df 93       	push	r29
#endif

 void setup() 	 
{ 	 
 
  	DDRB |= 0xFF;
 26e:	87 b3       	in	r24, 0x17	; 23
 270:	8f ef       	ldi	r24, 0xFF	; 255
 272:	87 bb       	out	0x17, r24	; 23
	PORTB |= 0x00;
 274:	88 b3       	in	r24, 0x18	; 24
 276:	88 bb       	out	0x18, r24	; 24

static inline void doSound(void)
{
	
	//On timer and setting
	TCCR0A = (1 << COM0A0) | (1 << WGM01);	//Toggle OC0A (PB0) on Compare Match ; mode = CTC
 278:	82 e4       	ldi	r24, 0x42	; 66
 27a:	8f bd       	out	0x2f, r24	; 47
	TCCR0B = (1 << CS01) | (1 << CS00);		//Clock Select = F_CPU/64
 27c:	83 e0       	ldi	r24, 0x03	; 3
 27e:	83 bf       	out	0x33, r24	; 51
 280:	c0 e0       	ldi	r28, 0x00	; 0
 282:	d0 e0       	ldi	r29, 0x00	; 0
 284:	fe 01       	movw	r30, r28
 286:	ec 5e       	subi	r30, 0xEC	; 236
 288:	ff 4f       	sbci	r31, 0xFF	; 255
	
	//playing notes
	for (uint8_t i = 0; i < COUNT_NOTES; i++)
	{
		//read data from mem
		int16_t freq = pgm_read_word(&(frequences[i]));
 28a:	25 91       	lpm	r18, Z+
 28c:	34 91       	lpm	r19, Z+
 28e:	fe 01       	movw	r30, r28
 290:	e0 5c       	subi	r30, 0xC0	; 192
 292:	ff 4f       	sbci	r31, 0xFF	; 255
		int16_t dur = pgm_read_word(&(durations[i]));
 294:	05 91       	lpm	r16, Z+
 296:	14 91       	lpm	r17, Z+
		//Amplifation duration 1.5 time
//		dur *= 2;
//		dur /= 2;
		
		//Enter freq in the exit PB0
		OCR0A = (F_CPU / (2UL * 64UL * freq)) - 1;
 298:	44 27       	eor	r20, r20
 29a:	37 fd       	sbrc	r19, 7
 29c:	40 95       	com	r20
 29e:	54 2f       	mov	r21, r20
 2a0:	87 e0       	ldi	r24, 0x07	; 7
 2a2:	22 0f       	add	r18, r18
 2a4:	33 1f       	adc	r19, r19
 2a6:	44 1f       	adc	r20, r20
 2a8:	55 1f       	adc	r21, r21
 2aa:	8a 95       	dec	r24
 2ac:	d1 f7       	brne	.-12     	; 0x2a2 <march+0x3c>
 2ae:	60 e0       	ldi	r22, 0x00	; 0
 2b0:	7c e7       	ldi	r23, 0x7C	; 124
 2b2:	82 e9       	ldi	r24, 0x92	; 146
 2b4:	90 e0       	ldi	r25, 0x00	; 0
 2b6:	22 d0       	rcall	.+68     	; 0x2fc <__udivmodsi4>
 2b8:	21 50       	subi	r18, 0x01	; 1
 2ba:	26 bf       	out	0x36, r18	; 54
		PORTB = OCR0A&0x55;
 2bc:	86 b7       	in	r24, 0x36	; 54
 2be:	85 75       	andi	r24, 0x55	; 85
 2c0:	88 bb       	out	0x18, r24	; 24
 2c2:	04 c0       	rjmp	.+8      	; 0x2cc <march+0x66>
		//waiting
		while (dur > 0)
		{	
			delay_ms(10);;
 2c4:	8a e0       	ldi	r24, 0x0A	; 10
 2c6:	0c df       	rcall	.-488    	; 0xe0 <delay_ms>
			dur -= 10;
 2c8:	0a 50       	subi	r16, 0x0A	; 10
 2ca:	10 40       	sbci	r17, 0x00	; 0
		
		//Enter freq in the exit PB0
		OCR0A = (F_CPU / (2UL * 64UL * freq)) - 1;
		PORTB = OCR0A&0x55;
		//waiting
		while (dur > 0)
 2cc:	10 16       	cp	r1, r16
 2ce:	11 06       	cpc	r1, r17
 2d0:	cc f3       	brlt	.-14     	; 0x2c4 <march+0x5e>
 2d2:	22 96       	adiw	r28, 0x02	; 2
	//On timer and setting
	TCCR0A = (1 << COM0A0) | (1 << WGM01);	//Toggle OC0A (PB0) on Compare Match ; mode = CTC
	TCCR0B = (1 << CS01) | (1 << CS00);		//Clock Select = F_CPU/64
	
	//playing notes
	for (uint8_t i = 0; i < COUNT_NOTES; i++)
 2d4:	cc 32       	cpi	r28, 0x2C	; 44
 2d6:	d1 05       	cpc	r29, r1
 2d8:	a9 f6       	brne	.-86     	; 0x284 <march+0x1e>
			dur -= 10;
		}
	}
	
	//Timer off
	TCCR0A = 0;
 2da:	1f bc       	out	0x2f, r1	; 47
	TCCR0B = 0;
 2dc:	13 be       	out	0x33, r1	; 51

void march()
{ 	 
		setup();
		doSound();
		PORTB = 0x00;
 2de:	18 ba       	out	0x18, r1	; 24
		DDRB = 0x00;
 2e0:	17 ba       	out	0x17, r1	; 23
		set_sleep_mode(SLEEP_MODE_PWR_DOWN);
 2e2:	85 b7       	in	r24, 0x35	; 53
 2e4:	87 7e       	andi	r24, 0xE7	; 231
 2e6:	80 61       	ori	r24, 0x10	; 16
 2e8:	85 bf       	out	0x35, r24	; 53
		sleep_enable(); 
 2ea:	85 b7       	in	r24, 0x35	; 53
 2ec:	80 62       	ori	r24, 0x20	; 32
 2ee:	85 bf       	out	0x35, r24	; 53
    	sleep_cpu();
 2f0:	88 95       	sleep
}
 2f2:	df 91       	pop	r29
 2f4:	cf 91       	pop	r28
 2f6:	1f 91       	pop	r17
 2f8:	0f 91       	pop	r16
 2fa:	08 95       	ret

000002fc <__udivmodsi4>:
 2fc:	a1 e2       	ldi	r26, 0x21	; 33
 2fe:	1a 2e       	mov	r1, r26
 300:	aa 1b       	sub	r26, r26
 302:	bb 1b       	sub	r27, r27
 304:	fd 01       	movw	r30, r26
 306:	0d c0       	rjmp	.+26     	; 0x322 <__udivmodsi4_ep>

00000308 <__udivmodsi4_loop>:
 308:	aa 1f       	adc	r26, r26
 30a:	bb 1f       	adc	r27, r27
 30c:	ee 1f       	adc	r30, r30
 30e:	ff 1f       	adc	r31, r31
 310:	a2 17       	cp	r26, r18
 312:	b3 07       	cpc	r27, r19
 314:	e4 07       	cpc	r30, r20
 316:	f5 07       	cpc	r31, r21
 318:	20 f0       	brcs	.+8      	; 0x322 <__udivmodsi4_ep>
 31a:	a2 1b       	sub	r26, r18
 31c:	b3 0b       	sbc	r27, r19
 31e:	e4 0b       	sbc	r30, r20
 320:	f5 0b       	sbc	r31, r21

00000322 <__udivmodsi4_ep>:
 322:	66 1f       	adc	r22, r22
 324:	77 1f       	adc	r23, r23
 326:	88 1f       	adc	r24, r24
 328:	99 1f       	adc	r25, r25
 32a:	1a 94       	dec	r1
 32c:	69 f7       	brne	.-38     	; 0x308 <__udivmodsi4_loop>
 32e:	60 95       	com	r22
 330:	70 95       	com	r23
 332:	80 95       	com	r24
 334:	90 95       	com	r25
 336:	9b 01       	movw	r18, r22
 338:	ac 01       	movw	r20, r24
 33a:	bd 01       	movw	r22, r26
 33c:	cf 01       	movw	r24, r30
 33e:	08 95       	ret

00000340 <__eerd_byte_tn13a>:
 340:	e1 99       	sbic	0x1c, 1	; 28
 342:	fe cf       	rjmp	.-4      	; 0x340 <__eerd_byte_tn13a>
 344:	1f ba       	out	0x1f, r1	; 31
 346:	8e bb       	out	0x1e, r24	; 30
 348:	e0 9a       	sbi	0x1c, 0	; 28
 34a:	99 27       	eor	r25, r25
 34c:	8d b3       	in	r24, 0x1d	; 29
 34e:	08 95       	ret

00000350 <__eewr_byte_tn13a>:
 350:	26 2f       	mov	r18, r22

00000352 <__eewr_r18_tn13a>:
 352:	e1 99       	sbic	0x1c, 1	; 28
 354:	fe cf       	rjmp	.-4      	; 0x352 <__eewr_r18_tn13a>
 356:	1c ba       	out	0x1c, r1	; 28
 358:	1f ba       	out	0x1f, r1	; 31
 35a:	8e bb       	out	0x1e, r24	; 30
 35c:	2d bb       	out	0x1d, r18	; 29
 35e:	0f b6       	in	r0, 0x3f	; 63
 360:	f8 94       	cli
 362:	e2 9a       	sbi	0x1c, 2	; 28
 364:	e1 9a       	sbi	0x1c, 1	; 28
 366:	0f be       	out	0x3f, r0	; 63
 368:	01 96       	adiw	r24, 0x01	; 1
 36a:	08 95       	ret

0000036c <_exit>:
 36c:	f8 94       	cli

0000036e <__stop_program>:
 36e:	ff cf       	rjmp	.-2      	; 0x36e <__stop_program>
